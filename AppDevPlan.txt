4th Jan
================
0, Open , save , save as vault file
     a, the vault will be saved always on device too in form of a file
     b, we can decide about the trigger / UI option to make explicit save / sync if required
     c,  this saved vault can be moved across devices 
     c, while opening give an option to refresh it from file system or continue to use the memory.
     d, for the first time when the user chooses to open i.e. when its created for first time , user is prompted to provide the location of teh file on the device.
     e, automatically always save to local file system in addition to browser memory
     f, while opening give an option to refresh it from file system or continue to use the memory.
     g, export should consider all the items irrespective of the filtered or not.
     h, while launching app it should always show the last vault file that was opened allowing user to choose a different vault file.
0.final, Open , save , save as vault file
     a, the vault will be saved always on device wherever supported, where need user friction like in safari/iOS, it will be saved via explicit user and till then it will stay in memory.
     b, we can decide about the trigger / UI option to make explicit save / sync if required
     c,  this saved vault can be moved across devices 
     c, while opening give an option to refresh it from file system or continue to use the memory.
     d, for the first time when the user chooses to open i.e. when its created for first time , user is prompted to provide the location of teh file on the device.
     e, automatically always save to local file system in addition to browser memory
     f, while opening give an option to refresh it from file system or continue to use the memory.
     g, export should consider all the items irrespective of the filtered or not.
     h, while launching app it should always show the last vault file that was opened allowing user to choose a different vault file.



1, to Allow export / open of vault so that
     a, the vault can be saved on device,
     b, this saved vault can be moved across devices 
     c, the saved vault can be uploaded to cloud services like OneDrive / Google Drive / email
     d, the saved vault can only be opened by this application and no other application / tools can open it. I am not sure if this is a possibility.
     e, automatically always save to local file system in addition to browser memory
     f, while opening give an option to refresh it from file system or continue to use the memory.
     g, export should consider all the items irrespective of the filtered or not.
     h, while exporting 
     i, i dont want to call it import instaed i want to call it open/load different vault, for example i could have different vault files.

2, Allow possibility to change the passphrase
      a, so that the vault can be re-encrypted with the new passphrase
      b, evaluate the strength of the passphrase during the change of passphrase or creating for the first time and show indicator via color red, amber, green
      c, 
3, Allow transform and load of some other vault which could be in clear text.
      a, is it possible to import the vault of application named password safe
4, Allow update and save/cancel of all the data elements name, username, password,url. the update of notes,tags is already allowed
5, show the total count and the filter count in form of <<filtercount>>/<<totalcount>>
6, Once the valut is opened using passphrase, want to allow opening using the finterprint but only within 1hr or 10hr of opening via passphrase
7, allow to read the url, username,suggested name from the image or picture taken
8, allow to delete the entries via single or multiple select. Given an option to move them all under single RECYCLEBIN tag by removing all existing tag, do not allow changes to the items when in RECYCLEBIN tag
9, Allow the operations using voice command
10, Allow to create a QR code for the URL so that someone can direclty go to the URL by scannign the QR.
11, Change of password reminder
    a, for the entry
    b, for the passphrase
    c, allow default to be no reminder for entry, but reminder mandatory for passphrase to 90days, however overridable or delay/ignore passphrase change action
 12, Integration of saving and loading vault from cloud
 13, enable hardbinding with the device, i.e. the device can be opened only on the device where it was created on.
 14, enable TFA - two factor authentication to open it after a span of say 12 hours.
 15, Export only filtered or visible items to create a new vault and optionally cahnge the passphrase for the exported one.
 16, Importing another vault in existing / currently open vault , ensuring key is unique and any duplicate key would put a popup of all such duplicates and ask user to choos which one to overwrite adn which one to ingore and which one to merge
 17, 
Perfectâ€”that simplifies things. Since thereâ€™s **no legacy data**, weâ€™ll start directly on **schema v2** and remove the migration task. Below is the updated plan (1â€“2 hrs/day), plus the readyâ€‘toâ€‘use **data model**, **crypto/storage stubs**, and **acceptance criteria**. You can copy these into mvault and begin.

***

## âœ… Finalized data model (v2 from day one)

```ts
// Encrypted payload for each credential
export type VaultItemPayload = {
  name: string;            // e.g., "GitHub", "Acme Bank"
  username: string;
  password: string;
  url?: string;
  tags: string[];          // normalized to lowercase
  notes?: string;          // up to 4000 chars (soft limit)
};

// Record stored in IndexedDB
export type VaultItem = {
  id: string;              // uuid
  createdAt: number;
  updatedAt: number;
  enc: {
    v: 2;                  // schema version
    iv: number[];          // AES-GCM 96-bit IV
    ct: number[];          // ciphertext bytes
  };
};

// Vault header (saved alongside DB metadata or in export file)
export type VaultHeader = {
  version: 1;
  kdf: { type: 'PBKDF2'; hash: 'SHA-256'; iterations: number; salt: number[] };
};
```

> Everything (including **name**, **tags**, **notes**) is encrypted at rest. Weâ€™ll decrypt items **only after unlock**, keep them in memory, and clear on lock/blur/inactivity.

***

## ðŸ—ºï¸ Updated development plan (no migration), 1â€“2 hrs/day

### Week 1 â€” Core & Tags (top priority)

**Goal:** basic vault working endâ€‘toâ€‘end + tags editor in the drawer.

*   **Day 1:**
    *   Implement **KDF (PBKDF2â€‘SHA256)** + AESâ€‘GCM helpers.
    *   Create **unlock** screen (passphrase â†’ derive key â†’ keep only in memory).
    *   Add **autoâ€‘lock** timer (e.g., 10 min) + manual *Lock* button.

*   **Day 2:**
    *   IndexedDB store (one object store: `items`).
    *   CRUD API: `createItem(payload)`, `listItems()`, `updateItem(id, payload)`, `deleteItem(id)`.
    *   Wire encryption/decryption inside the store.

*   **Day 3:**
    *   List + detail **drawer** (your â€œrevealâ€‘oneâ€ UX baseline).
    *   **Holdâ€‘toâ€‘reveal** password; **autoâ€‘hide** after N seconds and on tab blur; **copy** button with 15s clipboard overwrite.

*   **Day 4:**
    *   **Tags** in the drawer: chips UI (add/remove, lowercase, dedupe, max length 32).
    *   Compute `allTags` after unlock by decrypting in memory.

*   **Day 5:**
    *   **Tag suggestions** (typeâ€‘ahead from `allTags`).
    *   Unit tests: crypto roundâ€‘trip; add/remove tags; reveal autoâ€‘hide.

### Week 2 â€” Tag filtering & grouping (top priority)

**Goal:** quick navigation by tags.

*   **Day 6:** Global **tag filter bar** (multiâ€‘select chips).
*   **Day 7:** Filter logic on decrypted items (AND logic; later add OR toggle if needed).
*   **Day 8:** **Grouping view**: left column lists tags with counts; click to filter.
*   **Day 9:** Keyboard shortcuts (`g t` open filter, `Esc` clear).
*   **Day 10:** Tests: filter correctness, lock clears state, perf on \~150 items.

### Week 3 â€” Long notes (2kâ€“4k) (priority)

**Goal:** secure notes per entry.

*   **Day 11:** Notes textarea in drawer (autoâ€‘resize, soft limit 4000, counter).
*   **Day 12:** Debounced **autosave** on blur; â€œSavedâ€ toast.
*   **Day 13:** Ensure notes hidden on blur/lock; never shown outside drawer.
*   **Day 14â€“15:** Tests: long notes roundâ€‘trip; accessibility (labels, focus, ARIA).

### Week 4 â€” Import (last priority)

**Goal:** safe, local import (CSV/JSON).

*   **Day 16:** Import modal (after unlock) + file picker/dragâ€‘drop.
*   **Day 17:** Parser + **normalizer** (map `title|label|site|app â†’ name`; split `tags`; truncate `notes`).
*   **Day 18:** **Preview table** (hide passwords by default; *holdâ€‘toâ€‘reveal* in preview); duplicate handling by `(name, username)` (and optional URL host).
*   **Day 19â€“20:** Commit encrypted items; tests for malformed input, duplicates, long notes.

### Week 5 â€” Optional polish

*   Tag maintenance (rename/merge tags across items).
*   Export presets (Generic CSV, KeePassâ€‘style CSV, Bitwardenâ€‘style CSV/JSON).
*   Lighthouse & a11y pass; small perf tweaks.

***

## ðŸ” Crypto & storage stubs (dropâ€‘in)

> You can paste these into a `crypto.ts` and `store.ts` as a starting point.

**`crypto.ts` (PBKDF2 + AESâ€‘GCM helpers)**

```ts
// crypto.ts
const enc = new TextEncoder();
const dec = new TextDecoder();

export async function deriveKey(passphrase: string, salt: Uint8Array, iterations = 250_000) {
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(passphrase), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', hash: 'SHA-256', salt, iterations },
    baseKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}

export function randIV() {
  return crypto.getRandomValues(new Uint8Array(12));
}

export async function encryptJSON(key: CryptoKey, obj: unknown) {
  const iv = randIV();
  const data = enc.encode(JSON.stringify(obj));
  const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, data);
  return { iv: Array.from(iv), ct: Array.from(new Uint8Array(ct)) };
}

export async function decryptJSON<T>(key: CryptoKey, ivArr: number[], ctArr: number[]): Promise<T> {
  const iv = new Uint8Array(ivArr);
  const ct = new Uint8Array(ctArr);
  const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
  return JSON.parse(dec.decode(new Uint8Array(pt))) as T;
}
```

**`store.ts` (IndexedDB + encrypted CRUD)**

```ts
// store.ts
import { encryptJSON, decryptJSON } from './crypto';

const DB_NAME = 'mvault';
const STORE = 'items';

export type EncryptedItem = {
  id: string;
  createdAt: number;
  updatedAt: number;
  enc: { v: 2; iv: number[]; ct: number[] };
};

function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE, { keyPath: 'id' });
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

export async function createItem(key: CryptoKey, id: string, payload: unknown) {
  const db = await openDB();
  const now = Date.now();
  const enc = await encryptJSON(key, payload);
  const item: EncryptedItem = { id, createdAt: now, updatedAt: now, enc: { v: 2, ...enc } };
  await txPut(db, item);
  db.close();
  return item;
}

export async function listItems<T>(key: CryptoKey): Promise<Array<{ item: EncryptedItem; payload: T }>> {
  const db = await openDB();
  const all = await txGetAll<EncryptedItem>(db);
  db.close();
  return Promise.all(all.map(async (i) => ({
    item: i,
    payload: await decryptJSON<T>(key, i.enc.iv, i.enc.ct)
  })));
}

export async function updateItem<T>(key: CryptoKey, i: EncryptedItem, payload: T) {
  const db = await openDB();
  const enc = await encryptJSON(key, payload);
  const upd: EncryptedItem = { ...i, updatedAt: Date.now(), enc: { v: 2, ...enc } };
  await txPut(db, upd);
  db.close();
  return upd;
}

export async function deleteItem(id: string) {
  const db = await openDB();
  await txDel(db, id);
  db.close();
}

function txPut(db: IDBDatabase, val: unknown) {
  return new Promise<void>((resolve, reject) => {
    const tx = db.transaction(STORE, 'readwrite');
    tx.objectStore(STORE).put(val);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
function txDel(db: IDBDatabase, key: IDBValidKey) {
  return new Promise<void>((resolve, reject) => {
    const tx = db.transaction(STORE, 'readwrite');
    tx.objectStore(STORE).delete(key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}
function txGetAll<T>(db: IDBDatabase) {
  return new Promise<T[]>((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = () => resolve(req.result as T[]);
    req.onerror = () => reject(req.error);
  });
}
```

> Weâ€™ll add the **revealâ€‘onlyâ€‘one**, **holdâ€‘toâ€‘reveal**, and **autoâ€‘hide** logic in the drawer component during Week 1, Day 3.

***

## ðŸ§ª Acceptance criteria snapshot

*   **Revealâ€‘one invariant**: at most one password visible; switching entries autoâ€‘hides previous.
*   **Tags**: add/remove in drawer; suggestions from existing tags; encrypted at rest.
*   **Tag search/grouping**: multiâ€‘tag filter; counts per tag; keyboard shortcuts.
*   **Notes (2kâ€“4k)**: autosave, encrypted at rest; hide on blur/lock.
*   **Import**: CSV/JSON normalized to `name` (accept `title|label|site|app`); preview with masked passwords; duplicates handled; all encryption clientâ€‘side.

***

## What Iâ€™ll do first (now that thereâ€™s no migration)

*   **Day 1â€“2**: finalize `crypto.ts` and `store.ts` (above), unlock screen, and inâ€‘memory key handling + autoâ€‘lock timer.
*   **Day 3**: drawer + revealâ€‘one behavior.
*   **Day 4â€“5**: tags editor + suggestions.

Would you like me to also scaffold the **import normalizer** (header mapping to `name`) now, or keep it for Week 4 as planned?
